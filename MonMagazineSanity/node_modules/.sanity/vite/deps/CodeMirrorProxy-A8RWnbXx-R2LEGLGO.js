import {
  esm_default
} from "./chunk-6MTLICZB.js";
import "./chunk-LETVB5UL.js";
import {
  Decoration,
  EditorView,
  HighlightStyle,
  StateEffect,
  StateField,
  StreamLanguage,
  lineNumbers,
  syntaxHighlighting,
  tags
} from "./chunk-CBJP6EGH.js";
import {
  CodeInputConfigContext,
  rem,
  rgba,
  useRootTheme,
  useTheme
} from "./chunk-OM4WFORM.js";
import "./chunk-TKDB22VR.js";
import "./chunk-Q6Q5XOVC.js";
import "./chunk-LD3VNU3R.js";
import "./chunk-B6QUAMBD.js";
import "./chunk-DG3JXI3H.js";
import "./chunk-NIMLFF4F.js";
import {
  require_jsx_runtime
} from "./chunk-4UOXVWM6.js";
import "./chunk-ORQM2G6B.js";
import {
  require_react
} from "./chunk-U3RAP3IQ.js";
import {
  __toESM
} from "./chunk-5IKWDFCZ.js";

// node_modules/@sanity/code-input/lib/_chunks/CodeMirrorProxy-A8RWnbXx.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@uiw/codemirror-themes/esm/index.js
var createTheme = (_ref) => {
  var {
    theme,
    settings = {},
    styles = []
  } = _ref;
  var themeOptions = {
    ".cm-gutters": {}
  };
  var baseStyle = {};
  if (settings.background) {
    baseStyle.backgroundColor = settings.background;
  }
  if (settings.backgroundImage) {
    baseStyle.backgroundImage = settings.backgroundImage;
  }
  if (settings.foreground) {
    baseStyle.color = settings.foreground;
  }
  if (settings.fontSize) {
    baseStyle.fontSize = settings.fontSize;
  }
  if (settings.background || settings.foreground) {
    themeOptions["&"] = baseStyle;
  }
  if (settings.fontFamily) {
    themeOptions["&.cm-editor .cm-scroller"] = {
      fontFamily: settings.fontFamily
    };
  }
  if (settings.gutterBackground) {
    themeOptions[".cm-gutters"].backgroundColor = settings.gutterBackground;
  }
  if (settings.gutterForeground) {
    themeOptions[".cm-gutters"].color = settings.gutterForeground;
  }
  if (settings.gutterBorder) {
    themeOptions[".cm-gutters"].borderRightColor = settings.gutterBorder;
  }
  if (settings.caret) {
    themeOptions[".cm-content"] = {
      caretColor: settings.caret
    };
    themeOptions[".cm-cursor, .cm-dropCursor"] = {
      borderLeftColor: settings.caret
    };
  }
  var activeLineGutterStyle = {};
  if (settings.gutterActiveForeground) {
    activeLineGutterStyle.color = settings.gutterActiveForeground;
  }
  if (settings.lineHighlight) {
    themeOptions[".cm-activeLine"] = {
      backgroundColor: settings.lineHighlight
    };
    activeLineGutterStyle.backgroundColor = settings.lineHighlight;
  }
  themeOptions[".cm-activeLineGutter"] = activeLineGutterStyle;
  if (settings.selection) {
    themeOptions["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
      background: settings.selection + " !important"
    };
  }
  if (settings.selectionMatch) {
    themeOptions["& .cm-selectionMatch"] = {
      backgroundColor: settings.selectionMatch
    };
  }
  var themeExtension = EditorView.theme(themeOptions, {
    dark: theme === "dark"
  });
  var highlightStyle = HighlightStyle.define(styles);
  var extension = [themeExtension, syntaxHighlighting(highlightStyle)];
  return extension;
};

// node_modules/@sanity/code-input/lib/_chunks/CodeMirrorProxy-A8RWnbXx.js
function useCodeMirrorTheme() {
  const theme = useTheme();
  return (0, import_react.useMemo)(() => {
    const {
      code: codeFont
    } = theme.sanity.fonts;
    const {
      base,
      card,
      dark,
      syntax
    } = theme.sanity.color;
    return createTheme({
      theme: dark ? "dark" : "light",
      settings: {
        background: card.enabled.bg,
        foreground: card.enabled.code.fg,
        lineHighlight: card.enabled.bg,
        fontFamily: codeFont.family,
        caret: base.focusRing,
        selection: rgba(base.focusRing, 0.2),
        selectionMatch: rgba(base.focusRing, 0.4),
        gutterBackground: card.disabled.bg,
        gutterForeground: card.disabled.code.fg,
        gutterActiveForeground: card.enabled.fg
      },
      styles: [{
        tag: [tags.heading, tags.heading2, tags.heading3, tags.heading4, tags.heading5, tags.heading6],
        color: card.enabled.fg
      }, {
        tag: tags.angleBracket,
        color: card.enabled.code.fg
      }, {
        tag: tags.atom,
        color: syntax.keyword
      }, {
        tag: tags.attributeName,
        color: syntax.attrName
      }, {
        tag: tags.bool,
        color: syntax.boolean
      }, {
        tag: tags.bracket,
        color: card.enabled.code.fg
      }, {
        tag: tags.className,
        color: syntax.className
      }, {
        tag: tags.comment,
        color: syntax.comment
      }, {
        tag: tags.definition(tags.typeName),
        color: syntax.function
      }, {
        tag: [tags.definition(tags.variableName), tags.function(tags.variableName), tags.className, tags.attributeName],
        color: syntax.function
      }, {
        tag: [tags.function(tags.propertyName), tags.propertyName],
        color: syntax.function
      }, {
        tag: tags.keyword,
        color: syntax.keyword
      }, {
        tag: tags.null,
        color: syntax.number
      }, {
        tag: tags.number,
        color: syntax.number
      }, {
        tag: tags.meta,
        color: card.enabled.code.fg
      }, {
        tag: tags.operator,
        color: syntax.operator
      }, {
        tag: tags.propertyName,
        color: syntax.property
      }, {
        tag: [tags.string, tags.special(tags.brace)],
        color: syntax.string
      }, {
        tag: tags.tagName,
        color: syntax.className
      }, {
        tag: tags.typeName,
        color: syntax.keyword
      }]
    });
  }, [theme]);
}
var defaultCodeModes = [{
  name: "groq",
  loader: () => import("./dist-QNSUHMT5.js").then((_ref) => {
    let {
      javascriptLanguage
    } = _ref;
    return javascriptLanguage;
  })
}, {
  name: "javascript",
  loader: () => import("./dist-QNSUHMT5.js").then((_ref2) => {
    let {
      javascript
    } = _ref2;
    return javascript({
      jsx: false
    });
  })
}, {
  name: "jsx",
  loader: () => import("./dist-QNSUHMT5.js").then((_ref3) => {
    let {
      javascript
    } = _ref3;
    return javascript({
      jsx: true
    });
  })
}, {
  name: "typescript",
  loader: () => import("./dist-QNSUHMT5.js").then((_ref4) => {
    let {
      javascript
    } = _ref4;
    return javascript({
      jsx: false,
      typescript: true
    });
  })
}, {
  name: "tsx",
  loader: () => import("./dist-QNSUHMT5.js").then((_ref5) => {
    let {
      javascript
    } = _ref5;
    return javascript({
      jsx: true,
      typescript: true
    });
  })
}, {
  name: "php",
  loader: () => import("./dist-A36OAQHD.js").then((_ref6) => {
    let {
      php
    } = _ref6;
    return php();
  })
}, {
  name: "sql",
  loader: () => import("./dist-UDIHACS3.js").then((_ref7) => {
    let {
      sql
    } = _ref7;
    return sql();
  })
}, {
  name: "mysql",
  loader: () => import("./dist-UDIHACS3.js").then((_ref8) => {
    let {
      sql,
      MySQL
    } = _ref8;
    return sql({
      dialect: MySQL
    });
  })
}, {
  name: "json",
  loader: () => import("./dist-AOFUYRLM.js").then((_ref9) => {
    let {
      json
    } = _ref9;
    return json();
  })
}, {
  name: "markdown",
  loader: () => import("./dist-KS3N3BCS.js").then((_ref10) => {
    let {
      markdown
    } = _ref10;
    return markdown();
  })
}, {
  name: "java",
  loader: () => import("./dist-ECXOGMIV.js").then((_ref11) => {
    let {
      java
    } = _ref11;
    return java();
  })
}, {
  name: "html",
  loader: () => import("./dist-XF5VIIJW.js").then((_ref12) => {
    let {
      html
    } = _ref12;
    return html();
  })
}, {
  name: "csharp",
  loader: () => import("./clike-GUIIP25W.js").then((_ref13) => {
    let {
      csharp
    } = _ref13;
    return StreamLanguage.define(csharp);
  })
}, {
  name: "sh",
  loader: () => import("./shell-2N5YNGSW.js").then((_ref14) => {
    let {
      shell
    } = _ref14;
    return StreamLanguage.define(shell);
  })
}, {
  name: "css",
  loader: () => import("./css-ISIJO2PV.js").then((_ref15) => {
    let {
      css
    } = _ref15;
    return StreamLanguage.define(css);
  })
}, {
  name: "scss",
  loader: () => import("./css-ISIJO2PV.js").then((_ref16) => {
    let {
      css
    } = _ref16;
    return StreamLanguage.define(css);
  })
}, {
  name: "sass",
  loader: () => import("./sass-GNEBAWUJ.js").then((_ref17) => {
    let {
      sass
    } = _ref17;
    return StreamLanguage.define(sass);
  })
}, {
  name: "ruby",
  loader: () => import("./ruby-XIP634IM.js").then((_ref18) => {
    let {
      ruby
    } = _ref18;
    return StreamLanguage.define(ruby);
  })
}, {
  name: "python",
  loader: () => import("./python-RLE34M3J.js").then((_ref19) => {
    let {
      python
    } = _ref19;
    return StreamLanguage.define(python);
  })
}, {
  name: "xml",
  loader: () => import("./xml-QLW56B7B.js").then((_ref20) => {
    let {
      xml
    } = _ref20;
    return StreamLanguage.define(xml);
  })
}, {
  name: "yaml",
  loader: () => import("./yaml-IHFJ3YAG.js").then((_ref21) => {
    let {
      yaml
    } = _ref21;
    return StreamLanguage.define(yaml);
  })
}, {
  name: "golang",
  loader: () => import("./go-BODCAPBG.js").then((_ref22) => {
    let {
      go
    } = _ref22;
    return StreamLanguage.define(go);
  })
}, {
  name: "text",
  loader: () => void 0
}, {
  name: "batch",
  loader: () => void 0
}];
var highlightLineClass = "cm-highlight-line";
var addLineHighlight = StateEffect.define();
var removeLineHighlight = StateEffect.define();
var lineHighlightField = StateField.define({
  create() {
    return Decoration.none;
  },
  update(lines, tr) {
    lines = lines.map(tr.changes);
    for (const e of tr.effects) {
      if (e.is(addLineHighlight)) {
        lines = lines.update({
          add: [lineHighlightMark.range(e.value)]
        });
      }
      if (e.is(removeLineHighlight)) {
        lines = lines.update({
          filter: (from) => {
            return from !== e.value;
          }
        });
      }
    }
    return lines;
  },
  toJSON(value, state) {
    const highlightLines = [];
    const iter = value.iter();
    while (iter.value) {
      const lineNumber = state.doc.lineAt(iter.from).number;
      if (!highlightLines.includes(lineNumber)) {
        highlightLines.push(lineNumber);
      }
      iter.next();
    }
    return highlightLines;
  },
  fromJSON(value, state) {
    const lines = state.doc.lines;
    const highlights = value.filter((line) => line <= lines).map((line) => lineHighlightMark.range(state.doc.line(line).from));
    highlights.sort((a, b) => a.from - b.from);
    try {
      return Decoration.none.update({
        add: highlights
      });
    } catch (e) {
      console.error(e);
      return Decoration.none;
    }
  },
  provide: (f) => EditorView.decorations.from(f)
});
var lineHighlightMark = Decoration.line({
  class: highlightLineClass
});
var highlightState = {
  highlight: lineHighlightField
};
function createCodeMirrorTheme(options) {
  const {
    themeCtx
  } = options;
  const dark = {
    color: themeCtx.theme.color.dark[themeCtx.tone]
  };
  const light = {
    color: themeCtx.theme.color.light[themeCtx.tone]
  };
  return EditorView.baseTheme({
    ".cm-lineNumbers": {
      cursor: "default"
    },
    ".cm-line.cm-line": {
      position: "relative"
    },
    // need set background with pseudoelement so it does not render over selection color
    [".".concat(highlightLineClass, "::before")]: {
      position: "absolute",
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      zIndex: -3,
      content: "''",
      boxSizing: "border-box"
    },
    ["&dark .".concat(highlightLineClass, "::before")]: {
      background: rgba(dark.color.muted.caution.pressed.bg, 0.5)
    },
    ["&light .".concat(highlightLineClass, "::before")]: {
      background: rgba(light.color.muted.caution.pressed.bg, 0.75)
    }
  });
}
var highlightLine = (config) => {
  const highlightTheme = createCodeMirrorTheme({
    themeCtx: config.theme
  });
  return [lineHighlightField, config.readOnly ? [] : lineNumbers({
    domEventHandlers: {
      mousedown: (editorView, lineInfo) => {
        const line = editorView.state.doc.lineAt(lineInfo.from);
        let isHighlighted = false;
        editorView.state.field(lineHighlightField).between(line.from, line.to, (from, to, value) => {
          if (value) {
            isHighlighted = true;
            return false;
          }
          return void 0;
        });
        if (isHighlighted) {
          editorView.dispatch({
            effects: removeLineHighlight.of(line.from)
          });
        } else {
          editorView.dispatch({
            effects: addLineHighlight.of(line.from)
          });
        }
        if (config == null ? void 0 : config.onHighlightChange) {
          config.onHighlightChange(editorView.state.toJSON(highlightState).highlight);
        }
        return true;
      }
    }
  }), highlightTheme];
};
function setHighlightedLines(view, highlightLines) {
  const doc = view.state.doc;
  const lines = doc.lines;
  const allLineNumbers = Array.from({
    length: lines
  }, (x, i) => i + 1);
  view.dispatch({
    effects: allLineNumbers.map((lineNumber) => {
      const line = doc.line(lineNumber);
      if (highlightLines == null ? void 0 : highlightLines.includes(lineNumber)) {
        return addLineHighlight.of(line.from);
      }
      return removeLineHighlight.of(line.from);
    })
  });
}
function useFontSizeExtension(props) {
  const {
    fontSize: fontSizeProp
  } = props;
  const theme = useTheme();
  return (0, import_react.useMemo)(() => {
    const {
      code: codeFont
    } = theme.sanity.fonts;
    const {
      fontSize,
      lineHeight
    } = codeFont.sizes[fontSizeProp] || codeFont.sizes[2];
    return EditorView.baseTheme({
      "&": {
        fontSize: rem(fontSize)
      },
      "& .cm-scroller": {
        lineHeight: "".concat(lineHeight / fontSize, " !important")
      }
    });
  }, [fontSizeProp, theme]);
}
function useThemeExtension() {
  const themeCtx = useRootTheme();
  return (0, import_react.useMemo)(() => {
    const dark = {
      color: themeCtx.theme.color.dark[themeCtx.tone]
    };
    const light = {
      color: themeCtx.theme.color.light[themeCtx.tone]
    };
    return EditorView.baseTheme({
      "&.cm-editor": {
        height: "100%"
      },
      "&.cm-editor.cm-focused": {
        outline: "none"
      },
      // Matching brackets
      "&.cm-editor.cm-focused .cm-matchingBracket": {
        backgroundColor: "transparent"
      },
      "&.cm-editor.cm-focused .cm-nonmatchingBracket": {
        backgroundColor: "transparent"
      },
      "&dark.cm-editor.cm-focused .cm-matchingBracket": {
        outline: "1px solid ".concat(dark.color.base.border)
      },
      "&dark.cm-editor.cm-focused .cm-nonmatchingBracket": {
        outline: "1px solid ".concat(dark.color.base.border)
      },
      "&light.cm-editor.cm-focused .cm-matchingBracket": {
        outline: "1px solid ".concat(light.color.base.border)
      },
      "&light.cm-editor.cm-focused .cm-nonmatchingBracket": {
        outline: "1px solid ".concat(light.color.base.border)
      },
      // Size and padding of gutter
      "& .cm-lineNumbers .cm-gutterElement": {
        minWidth: "32px !important",
        padding: "0 8px !important"
      },
      "& .cm-gutter.cm-foldGutter": {
        width: "0px !important"
      },
      // Color of gutter
      "&dark .cm-gutters": {
        color: "".concat(rgba(dark.color.card.enabled.code.fg, 0.5), " !important"),
        borderRight: "1px solid ".concat(rgba(dark.color.base.border, 0.5))
      },
      "&light .cm-gutters": {
        color: "".concat(rgba(light.color.card.enabled.code.fg, 0.5), " !important"),
        borderRight: "1px solid ".concat(rgba(light.color.base.border, 0.5))
      }
    });
  }, [themeCtx]);
}
var CodeMirrorProxy = (0, import_react.forwardRef)(function CodeMirrorProxy2(props, ref) {
  const {
    basicSetup: basicSetupProp,
    highlightLines,
    languageMode,
    onHighlightChange,
    readOnly,
    value,
    ...codeMirrorProps
  } = props;
  const themeCtx = useRootTheme();
  const codeMirrorTheme = useCodeMirrorTheme();
  const [editorView, setEditorView] = (0, import_react.useState)(void 0);
  const themeExtension = useThemeExtension();
  const fontSizeExtension = useFontSizeExtension({
    fontSize: 1
  });
  const languageExtension = useLanguageExtension(languageMode);
  const highlightLineExtension = (0, import_react.useMemo)(() => highlightLine({
    onHighlightChange,
    readOnly,
    theme: themeCtx
  }), [onHighlightChange, readOnly, themeCtx]);
  const extensions = (0, import_react.useMemo)(() => {
    const baseExtensions = [themeExtension, fontSizeExtension, highlightLineExtension, EditorView.lineWrapping];
    if (languageExtension) {
      return [...baseExtensions, languageExtension];
    }
    return baseExtensions;
  }, [fontSizeExtension, highlightLineExtension, languageExtension, themeExtension]);
  (0, import_react.useEffect)(() => {
    if (editorView) {
      setHighlightedLines(editorView, highlightLines != null ? highlightLines : []);
    }
  }, [editorView, highlightLines, value]);
  const initialState = (0, import_react.useMemo)(() => {
    return {
      json: {
        doc: value != null ? value : "",
        selection: {
          main: 0,
          ranges: [{
            anchor: 0,
            head: 0
          }]
        },
        highlight: highlightLines != null ? highlightLines : []
      },
      fields: highlightState
    };
  }, []);
  const handleCreateEditor = (0, import_react.useCallback)((view) => {
    setEditorView(view);
  }, []);
  const basicSetup = (0, import_react.useMemo)(() => basicSetupProp != null ? basicSetupProp : {
    highlightActiveLine: false
  }, [basicSetupProp]);
  return (0, import_jsx_runtime.jsx)(esm_default, {
    ...codeMirrorProps,
    value,
    ref,
    extensions,
    theme: codeMirrorTheme,
    onCreateEditor: handleCreateEditor,
    initialState,
    basicSetup
  });
});
function useLanguageExtension(mode) {
  const codeConfig = (0, import_react.useContext)(CodeInputConfigContext);
  const [languageExtension, setLanguageExtension] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    var _a;
    const customModes = (_a = codeConfig == null ? void 0 : codeConfig.codeModes) != null ? _a : [];
    const modes = [...customModes, ...defaultCodeModes];
    const codeMode = modes.find((m) => m.name === mode);
    if (!(codeMode == null ? void 0 : codeMode.loader)) {
      console.warn("Found no codeMode for language mode ".concat(mode, ", syntax highlighting will be disabled."));
    }
    let active = true;
    Promise.resolve(codeMode == null ? void 0 : codeMode.loader()).then((extension) => {
      if (active) {
        setLanguageExtension(extension);
      }
    }).catch((e) => {
      console.error("Failed to load language mode ".concat(mode), e);
      if (active) {
        setLanguageExtension(void 0);
      }
    });
    return () => {
      active = false;
    };
  }, [mode, codeConfig]);
  return languageExtension;
}
export {
  CodeMirrorProxy as default
};
//# sourceMappingURL=CodeMirrorProxy-A8RWnbXx-R2LEGLGO.js.map
