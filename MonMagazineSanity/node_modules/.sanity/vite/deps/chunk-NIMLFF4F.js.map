{
  "version": 3,
  "sources": ["../../../@portabletext/toolkit/src/asserters.ts", "../../../@portabletext/toolkit/src/sortMarksByOccurences.ts", "../../../@portabletext/toolkit/src/buildMarksTree.ts", "../../../@portabletext/toolkit/src/nestLists.ts", "../../../@portabletext/toolkit/src/spanToPlainText.ts", "../../../@portabletext/toolkit/src/toPlainText.ts", "../../../@portabletext/toolkit/src/types.ts", "../../../@portabletext/to-html/src/components/list.ts", "../../../@portabletext/to-html/src/escape.ts", "../../../@portabletext/to-html/src/components/marks.ts", "../../../@portabletext/to-html/src/warnings.ts", "../../../@portabletext/to-html/src/components/unknown.ts", "../../../@portabletext/to-html/src/components/defaults.ts", "../../../@portabletext/to-html/src/components/merge.ts", "../../../@portabletext/to-html/src/to-html.ts"],
  "sourcesContent": ["import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n", "import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children} = block\n  const markDefs = block.markDefs ?? []\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs?.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n", "import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n", "import {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\nimport type {ToolkitNestedPortableTextSpan} from './types'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n", "import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\n\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /\\s$/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[],\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (\n    | ToolkitTextNode\n    | ToolkitNestedPortableTextSpan<PortableTextMarkDefinition>\n    | ArbitraryTypedObject\n  )[]\n}\n", "import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => `<ol>${children}</ol>`,\n  bullet: ({children}) => `<ul>${children}</ul>`,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => `<li>${children}</li>`\n", "const allowedProtocols = ['http', 'https', 'mailto', 'tel']\nconst charMap: Record<string, string> = {\n  '&': 'amp',\n  '<': 'lt',\n  '>': 'gt',\n  '\"': 'quot',\n  \"'\": '#x27',\n}\n\nexport function escapeHTML(str: string): string {\n  return str.replace(/[&<>\"']/g, (s) => `&${charMap[s]};`)\n}\n\nexport function uriLooksSafe(uri: string): boolean {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  // Allow hash-links, absolute paths and \"same-protocol\" (//foo.bar) URLs\n  if (first === '#' || first === '/') {\n    return true\n  }\n\n  // If the URL does not contain a `:`, allow it\n  const colonIndex = url.indexOf(':')\n  if (colonIndex === -1) {\n    return true\n  }\n\n  // If the protocol is in the allowed list, treat it as OK\n  const proto = url.slice(0, colonIndex).toLowerCase()\n  if (allowedProtocols.indexOf(proto) !== -1) {\n    return true\n  }\n\n  // If the URL is `site/search?query=author:espen`, allow it\n  const queryIndex = url.indexOf('?')\n  if (queryIndex !== -1 && colonIndex > queryIndex) {\n    return true\n  }\n\n  // If the URL is `site/search#my:encoded:data`, allow it\n  const hashIndex = url.indexOf('#')\n  if (hashIndex !== -1 && colonIndex > hashIndex) {\n    return true\n  }\n\n  return false\n}\n", "import type {TypedObject} from '@portabletext/types'\n\nimport {escapeHTML, uriLooksSafe} from '../escape'\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => {\n  const href = value?.href || ''\n  const looksSafe = uriLooksSafe(href)\n  return looksSafe ? `<a href=\"${escapeHTML(href)}\">${children}</a>` : children\n}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => `<em>${children}</em>`,\n  strong: ({children}) => `<strong>${children}</strong>`,\n  code: ({children}) => `<code>${children}</code>`,\n  underline: ({children}) => `<span style=\"text-decoration:underline\">${children}</span>`,\n  'strike-through': ({children}) => `<del>${children}</del>`,\n  link,\n}\n", "const getTemplate = (type: string, prop: string): string =>\n  `Unknown ${type}, specify a component for it in the \\`components.${prop}\\` option`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  console.warn(message)\n}\n", "import type {PortableTextHtmlComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nexport const DefaultUnknownType: PortableTextHtmlComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline\n    ? `<span style=\"display:none\">${warning}</span>`\n    : `<div style=\"display:none\">${warning}</div>`\n}\n\nexport const DefaultUnknownMark: PortableTextHtmlComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return `<span class=\"unknown__pt__mark__${markType}\">${children}</span>`\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextHtmlComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return `<p>${children}</p>`\n}\n\nexport const DefaultUnknownList: PortableTextHtmlComponents['unknownList'] = ({children}) => {\n  return `<ul>${children}</ul>`\n}\n\nexport const DefaultUnknownListItem: PortableTextHtmlComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return `<li>${children}</li>`\n}\n", "import type {PortableTextBlockStyle} from '@portabletext/types'\n\nimport type {PortableTextBlockComponent, PortableTextHtmlComponents} from '../types'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): string => '<br/>'\n\nexport const defaultPortableTextBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => `<p>${children}</p>`,\n  blockquote: ({children}) => `<blockquote>${children}</blockquote>`,\n  h1: ({children}) => `<h1>${children}</h1>`,\n  h2: ({children}) => `<h2>${children}</h2>`,\n  h3: ({children}) => `<h3>${children}</h3>`,\n  h4: ({children}) => `<h4>${children}</h4>`,\n  h5: ({children}) => `<h5>${children}</h5>`,\n  h6: ({children}) => `<h6>${children}</h6>`,\n}\n\nexport const defaultComponents: PortableTextHtmlComponents = {\n  types: {},\n\n  block: defaultPortableTextBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n", "import type {PortableTextComponents, PortableTextHtmlComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n): PortableTextHtmlComponents {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {block, list, listItem, marks, types, ...rest} = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextHtmlComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextHtmlComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextHtmlComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextHtmlComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextHtmlComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextHtmlComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextHtmlComponents[typeof key]\n  }\n\n  return parentVal\n}\n", "import {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  nestLists,\n  spanToPlainText,\n  type ToolkitNestedPortableTextSpan,\n  type ToolkitTextNode,\n} from '@portabletext/toolkit'\nimport type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport {escapeHTML} from './escape'\nimport type {\n  HtmlPortableTextList,\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextHtmlComponents,\n  PortableTextOptions,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function toHTML<B extends TypedObject = PortableTextBlock | ArbitraryTypedObject>(\n  value: B | B[],\n  options: PortableTextOptions = {},\n): string {\n  const {\n    components: componentOverrides,\n    onMissingComponent: missingComponentHandler = printWarning,\n  } = options\n\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(value) ? value : [value]\n  const nested = nestLists(blocks, 'html')\n  const components = componentOverrides\n    ? mergeComponents(defaultComponents, componentOverrides)\n    : defaultComponents\n\n  const renderNode = getNodeRenderer(components, handleMissingComponent)\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return rendered.join('')\n}\n\nconst getNodeRenderer = (\n  components: PortableTextHtmlComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): string {\n    const {node, index, isInline} = options\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node)\n    }\n\n    return renderCustomBlock(node, index, isInline)\n  }\n\n  function renderListItem(\n    node: PortableTextListItemBlock<PortableTextMarkDefinition, PortableTextSpan>,\n    index: number,\n  ): string {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const itemHandler = handler || components.unknownListItem\n\n    if (itemHandler === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block component says to use\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {listItem, ...blockNode} = node\n      children = renderNode({node: blockNode, index, isInline: false, renderNode})\n    }\n\n    return itemHandler({value: node, index, isInline: false, renderNode, children})\n  }\n\n  function renderList(node: HtmlPortableTextList, index: number): string {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: index,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const list = handler || components.unknownList\n\n    if (list === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {nodeType: 'listStyle', type: style})\n    }\n\n    return list({value: node, index, isInline: false, renderNode, children: children.join('')})\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan): string {\n    const {markDef, markType, markKey} = node\n    const span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode}),\n    )\n\n    if (span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {nodeType: 'mark', type: markType})\n    }\n\n    return span({\n      text: spanToPlainText(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(''),\n    })\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, isInline: boolean): string {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const block = handler || components.unknownBlockStyle\n\n    if (block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return block({...props, value: props.node, renderNode})\n  }\n\n  function renderText(node: ToolkitTextNode): string {\n    if (node.text === '\\n') {\n      const hardBreak = components.hardBreak\n      return hardBreak ? hardBreak() : '\\n'\n    }\n\n    return escapeHTML(node.text)\n  }\n\n  function renderCustomBlock(value: TypedObject, index: number, isInline: boolean): string {\n    const node = components.types[value._type]\n\n    if (!node) {\n      handleMissingComponent(unknownTypeWarning(value._type), {\n        nodeType: 'block',\n        type: value._type,\n      })\n    }\n\n    const component = node || components.unknownType\n    return component({\n      value,\n      isInline,\n      index,\n      renderNode,\n    })\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children: children.join(''),\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],
  "mappings": "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",
  "names": ["isPortableTextSpan", "node", "_type", "text", "marks", "Array", "isArray", "every", "mark", "isPortableTextBlock", "markDefs", "def", "_key", "children", "child", "isPortableTextListItemBlock", "block", "listItem", "level", "isPortableTextToolkitList", "isPortableTextToolkitSpan", "span", "isPortableTextToolkitTextNode", "knownDecorators", "sortMarksByOccurences", "index", "blockChildren", "length", "slice", "occurences", "forEach", "siblingIndex", "sibling", "indexOf", "sort", "markA", "markB", "sortMarks", "aOccurences", "bOccurences", "aKnownPos", "bKnownPos", "localeCompare", "buildMarksTree", "_a", "_b", "sortedMarks", "map", "rootNode", "markType", "nodeStack", "i", "marksNeeded", "pos", "markKey", "splice", "currentNode", "markDef", "find", "push", "lines", "split", "line", "concat", "nestLists", "blocks", "mode", "tree", "currentList", "listFromBlock", "blockMatchesList", "newList", "lastListItem", "newLastChild", "_objectSpread", "matchingBranch", "match", "findListMatching", "console", "warn", "list", "matching", "style", "filterOnType", "spanToPlainText", "current", "leadingSpace", "trailingSpace", "toPlainText", "pad", "test", "LIST_NEST_MODE_HTML", "defaultLists", "number", "children", "bullet", "DefaultListItem", "allowedProtocols", "charMap", "escapeHTML", "str", "replace", "s", "uriLooksSafe", "uri", "url", "trim", "first", "charAt", "colonIndex", "indexOf", "proto", "slice", "toLowerCase", "queryIndex", "hashIndex", "link", "value", "href", "defaultMarks", "em", "strong", "code", "underline", "strike-through", "getTemplate", "type", "prop", "unknownTypeWarning", "typeName", "unknownMarkWarning", "markType", "unknownBlockStyleWarning", "blockStyle", "unknownListStyleWarning", "listStyle", "unknownListItemStyleWarning", "printWarning", "message", "console", "warn", "DefaultUnknownType", "isInline", "warning", "_type", "DefaultUnknownMark", "DefaultUnknownBlockStyle", "DefaultUnknownList", "DefaultUnknownListItem", "DefaultHardBreak", "defaultPortableTextBlockStyles", "normal", "blockquote", "h1", "h2", "h3", "h4", "h5", "h6", "defaultComponents", "types", "block", "marks", "list", "listItem", "hardBreak", "unknownType", "unknownMark", "unknownList", "unknownListItem", "unknownBlockStyle", "mergeComponents", "parent", "overrides", "rest", "_excluded", "_objectSpread", "mergeDeeply", "key", "override", "parentVal", "toHTML", "options", "components", "componentOverrides", "onMissingComponent", "missingComponentHandler", "handleMissingComponent", "noop", "blocks", "Array", "isArray", "nested", "nestLists", "renderNode", "getNodeRenderer", "map", "node", "index", "join", "isPortableTextToolkitList", "renderList", "isPortableTextListItemBlock", "renderListItem", "isPortableTextToolkitSpan", "renderSpan", "isPortableTextBlock", "renderBlock", "isPortableTextToolkitTextNode", "renderText", "renderCustomBlock", "tree", "serializeBlock", "renderer", "itemHandler", "style", "nodeType", "blockNode", "_objectWithoutProperties", "_excluded2", "child", "childIndex", "_key", "component", "markDef", "markKey", "span", "text", "spanToPlainText", "_serializeBlock", "props", "_excluded3", "buildMarksTree", "i"]
}
